#include <bits/stdc++.h>
using namespace std;
int a[110][110];//数独上的值
int b[110][110];//b[i][j]=1表示(i,j)以被固定 
int u[110][110]={
	{0,0,0,0,0,0,0,0,0,0},
	{0,6,6,6,6,6,6,6,6,6},
	{0,6,7,7,7,7,7,7,7,6},
	{0,6,7,8,8,8,8,8,7,6},
	{0,6,7,8,9,9,9,8,7,6},
	{0,6,7,8,9,10,9,8,7,6},
	{0,6,7,8,9,9,9,8,7,6},
	{0,6,7,8,8,8,8,8,7,6},
	{0,6,7,7,7,7,7,7,7,6},
	{0,6,6,6,6,6,6,6,6,6}
};//点权
int d[110][110]={
	{0,0,0,0,0,0,0,0,0,0},
	{0,1,1,1,2,2,2,3,3,3},
	{0,1,1,1,2,2,2,3,3,3},
	{0,1,1,1,2,2,2,3,3,3},
	{0,4,4,4,5,5,5,6,6,6},
	{0,4,4,4,5,5,5,6,6,6},
	{0,4,4,4,5,5,5,6,6,6},
	{0,7,7,7,8,8,8,9,9,9},
	{0,7,7,7,8,8,8,9,9,9},
	{0,7,7,7,8,8,8,9,9,9}
};//判断（i,j）在那个正方体中 
int r[110][110];//r[i][j]表示
int c[110][110];
int l[110][110];
int ans=0;
struct node{
	int cnt,id;
}cnt[110];
void dfs(int k,int x,int y,int sum){
	if(k==10){
		ans=max(ans,sum);
		return ;
	}
	if(y==10){
		dfs(k+1,cnt[k+1].id,1,sum);
		return ;
	}
	if(b[x][y]==1){
		dfs(k,x,y+1,sum+a[x][y]*u[x][y]);
	}
	else{
		for(int i=1;i<=9;++i){
			if(r[x][i]==0&&c[y][i]==0&&l[d[x][y]][i]==0){
				r[x][i]=1;
				c[y][i]=1;
				l[d[x][y]][i]=1;
				dfs(k,x,y+1,sum+i*u[x][y]);
				r[x][i]=0;
				c[y][i]=0;
				l[d[x][y]][i]=0;
			}
		}
	}
}
bool cmp(node u,node v){
	return u.cnt<v.cnt;
}
int main(){
	for(int i=1;i<=9;++i){
		for(int j=1;j<=9;++j){
			cin >> a[i][j];
			if(a[i][j]!=0){
				b[i][j]=1;
				r[i][a[i][j]]=1;
				c[j][a[i][j]]=1;
				l[d[i][j]][a[i][j]]=1;
			}
			else{
				cnt[i].cnt++;
				cnt[i].id=i;
			}
		}
	}
	sort(cnt+1,cnt+1+9,cmp);
	dfs(1,cnt[1].id,1,0);
	if(ans==0) ans=-1;
	cout << ans;
	return 0;
}
